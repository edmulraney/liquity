## API Report File for "@liquity/lib-base"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { Decimal } from '@liquity/decimal';
import { Decimalish } from '@liquity/decimal';

// @public (undocumented)
export type CollateralGainTransferDetails = StabilityPoolGainsWithdrawalDetails & {
    newTrove: Trove;
};

// @public (undocumented)
export type CollateralGainTransferOptionalParams = FeelessTroveAdjustmentOptionalParams & {
    deposit?: StabilityDeposit;
};

// @public (undocumented)
export const emptyTrove: Trove;

// @public (undocumented)
export type FailedReceipt<R = unknown> = {
    status: "failed";
    rawReceipt: R;
};

// @public (undocumented)
export const failedReceipt: <R>(rawReceipt: R) => FailedReceipt<R>;

// @public (undocumented)
export type FeelessTroveAdjustmentOptionalParams = HintedMethodOptionalParams & {
    trove?: Trove;
};

// @public (undocumented)
export class Fees {
    constructor(lastFeeOperation: Date, baseRateWithoutDecay: Decimalish, minuteDecayFactor: Decimalish, beta: Decimalish);
    // (undocumented)
    baseRate(when: Date): Decimal;
    // (undocumented)
    borrowingFeeFactor(when?: Date): Decimal;
    // (undocumented)
    equals(that: Fees): boolean;
    // (undocumented)
    redemptionFeeFactor(redeemedFractionOfSupply?: Decimalish, when?: Date): Decimal;
    // (undocumented)
    toString(): string;
}

// @public (undocumented)
export type FrontendStatus = {
    status: "unregistered";
} | {
    status: "registered";
    kickbackRate: Decimal;
};

// @public (undocumented)
export function glue<T, U>(t: new (...args: never[]) => T, u: new (...args: never[]) => U): new (t: T, u: U) => T & U;

// @public (undocumented)
export function glue<T, U, V>(t: new (...args: never[]) => T, u: new (...args: never[]) => U, v: new (...args: never[]) => V): new (t: T, u: U, v: V) => T & U & V;

// @public (undocumented)
export function glue<T, U, V, W>(t: new (...args: never[]) => T, u: new (...args: never[]) => U, v: new (...args: never[]) => V, w: new (...args: never[]) => W): new (t: T, u: U, v: V, w: W) => T & U & V & W;

// Warning: (ae-forgotten-export) The symbol "Hintable" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "AddParams" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TroveCreationMethod" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "FeelessTroveAdjustmentMethod" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "TroveAdjustmentMethod" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "CollateralGainTransferMethod" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "RedemptionMethod" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type Hinted<T extends Hintable> = T & AddParams<T, TroveCreationMethod, [optionalParams?: TroveCreationOptionalParams]> & AddParams<T, FeelessTroveAdjustmentMethod, [
    optionalParams?: FeelessTroveAdjustmentOptionalParams
]> & AddParams<T, TroveAdjustmentMethod, [optionalParams?: TroveAdjustmentOptionalParams]> & AddParams<T, CollateralGainTransferMethod, [
    optionalParams?: CollateralGainTransferOptionalParams
]> & AddParams<T, RedemptionMethod, [optionalParams?: RedemptionOptionalParams]>;

// @public (undocumented)
export type HintedMethodOptionalParams = {
    numberOfTroves?: number;
};

// @public (undocumented)
export const invalidTroveCreation: (invalidTrove: Trove, error: TroveCreationError) => TaggedInvalidTroveCreation;

// @public (undocumented)
export type LiquidationDetails = {
    liquidatedAddresses: string[];
    totalLiquidated: Trove;
    lusdGasCompensation: Decimal;
    collateralGasCompensation: Decimal;
};

// @public (undocumented)
export type LiquityReceipt<R = unknown, D = unknown> = PendingReceipt | MinedReceipt<R, D>;

// @public (undocumented)
export abstract class LiquityStore<T = unknown> {
    constructor(constants: LiquityStoreConstants);
    // (undocumented)
    protected constants: LiquityStoreConstants;
    // (undocumented)
    abstract doStart(): () => void;
    // (undocumented)
    protected load(baseState: LiquityStoreBaseState, extraState?: T): void;
    // (undocumented)
    protected loaded: boolean;
    // (undocumented)
    logging: boolean;
    // (undocumented)
    protected logUpdate<U>(name: string, next: U, show?: (next: U) => string): U;
    // (undocumented)
    onLoaded?: () => void;
    // (undocumented)
    protected abstract reduceExtra(extraState: T, extraStateUpdate: Partial<T>): T;
    // (undocumented)
    protected silentlyUpdateIfChanged<U>(equals: (a: U, b: U) => boolean, prev: U, next?: U): U;
    // (undocumented)
    start(): () => void;
    // (undocumented)
    get state(): LiquityStoreState<T>;
    // (undocumented)
    subscribe(listener: LiquityStoreListener<T>): () => void;
    // (undocumented)
    protected update(baseStateUpdate?: Partial<LiquityStoreBaseState>, extraStateUpdate?: Partial<T>): void;
    // (undocumented)
    protected updateIfChanged<U>(equals: (a: U, b: U) => boolean, name: string, prev: U, next?: U, show?: (next: U) => string): U;
    }

// @public (undocumented)
export type LiquityStoreBaseState = {
    frontend: FrontendStatus;
    ownFrontend: FrontendStatus;
    numberOfTroves: number;
    accountBalance: Decimal;
    lusdBalance: Decimal;
    lqtyBalance: Decimal;
    collateralSurplusBalance: Decimal;
    price: Decimal;
    lusdInStabilityPool: Decimal;
    total: Trove;
    totalRedistributed: Trove;
    troveWithoutRewards: TroveWithPendingRewards;
    deposit: StabilityDeposit;
    fees: Fees;
    lqtyStake: LQTYStake;
    totalStakedLQTY: Decimal;
};

// @public (undocumented)
export type LiquityStoreConstants = {
    frontendTag: string;
};

// @public (undocumented)
export type LiquityStoreDerivedState = {
    trove: Trove;
    borrowingFeeFactor: Decimal;
    redemptionFeeFactor: Decimal;
};

// @public (undocumented)
export type LiquityStoreListener<T = unknown> = (params: {
    newState: LiquityStoreState<T>;
    oldState: LiquityStoreState<T>;
    stateChange: Partial<LiquityStoreState<T>>;
}) => void;

// @public (undocumented)
export type LiquityStoreState<T = unknown> = T & LiquityStoreConstants & LiquityStoreBaseState & LiquityStoreDerivedState;

// @public (undocumented)
export class LQTYStake {
    // Warning: (ae-forgotten-export) The symbol "LQTYStakish" needs to be exported by the entry point index.d.ts
    constructor({ stakedLQTY, collateralGain, lusdGain }: LQTYStakish);
    // (undocumented)
    apply(change: LQTYStakeChange<Decimalish> | undefined): Decimal;
    // (undocumented)
    readonly collateralGain: Decimal;
    // (undocumented)
    equals(that: LQTYStake): boolean;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    readonly lusdGain: Decimal;
    // (undocumented)
    readonly stakedLQTY: Decimal;
    // (undocumented)
    toString(): string;
    // Warning: (ae-forgotten-export) The symbol "LQTYStakeChange" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    whatChanged(thatStakedLQTY: Decimalish): LQTYStakeChange<Decimal> | undefined;
}

// @public (undocumented)
export type MinedReceipt<R = unknown, D = unknown> = FailedReceipt<R> | SuccessfulReceipt<R, D>;

// Warning: (ae-forgotten-export) The symbol "Normalizer" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export const normalizeTroveAdjustment: Normalizer<TroveAdjustment<Decimalish>, TroveAdjustment<Decimal>>;

// @public (undocumented)
export const normalizeTroveCreation: Normalizer<TroveCreation<Decimalish>, TroveCreation<Decimal>>;

// @public (undocumented)
export interface ObservableLiquity {
    // (undocumented)
    watchLUSDBalance(onLUSDBalanceChanged: (balance: Decimal) => void, address?: string): () => void;
    // (undocumented)
    watchLUSDInStabilityPool(onLUSDInStabilityPoolChanged: (lusdInStabilityPool: Decimal) => void): () => void;
    // (undocumented)
    watchNumberOfTroves(onNumberOfTrovesChanged: (numberOfTroves: number) => void): () => void;
    // (undocumented)
    watchPrice(onPriceChanged: (price: Decimal) => void): () => void;
    // (undocumented)
    watchStabilityDeposit(onStabilityDepositChanged: (deposit: StabilityDeposit) => void, address?: string): () => void;
    // (undocumented)
    watchTotal(onTotalChanged: (total: Trove) => void): () => void;
    // (undocumented)
    watchTotalRedistributed(onTotalRedistributedChanged: (totalRedistributed: Trove) => void): () => void;
    // (undocumented)
    watchTroveWithoutRewards(onTroveChanged: (trove: TroveWithPendingRewards) => void, address?: string): () => void;
}

// @public (undocumented)
export type PendingReceipt = {
    status: "pending";
};

// @public (undocumented)
export const pendingReceipt: PendingReceipt;

// @public (undocumented)
export type Populatable<T, R = unknown, S = unknown, P = unknown> = {
    [M in keyof T]: T[M] extends (...args: infer A) => Promise<infer D> ? PopulateMethod<A, PopulatedLiquityTransaction<P, SentLiquityTransaction<S, LiquityReceipt<R, D>>>> : never;
};

// @public (undocumented)
export type PopulatedLiquityTransaction<P = unknown, T extends SentLiquityTransaction = SentLiquityTransaction> = {
    rawPopulatedTransaction: P;
    send(): Promise<T>;
};

// @public (undocumented)
export type PopulateMethod<A extends unknown[], T extends PopulatedLiquityTransaction> = (...args: A) => Promise<T>;

// @public (undocumented)
export interface ReadableLiquity {
    // (undocumented)
    getCollateralSurplusBalance(address?: string): Promise<Decimal>;
    // (undocumented)
    getFees(): Promise<Fees>;
    // (undocumented)
    getFirstTroves(startIdx: number, numberOfTroves: number): Promise<[string, TroveWithPendingRewards][]>;
    // (undocumented)
    getFrontendStatus(address?: string): Promise<FrontendStatus>;
    // (undocumented)
    getLastTroves(startIdx: number, numberOfTroves: number): Promise<[string, TroveWithPendingRewards][]>;
    // (undocumented)
    getLQTYBalance(address?: string): Promise<Decimal>;
    // (undocumented)
    getLQTYStake(address?: string): Promise<LQTYStake>;
    // (undocumented)
    getLUSDBalance(address?: string): Promise<Decimal>;
    // (undocumented)
    getLUSDInStabilityPool(): Promise<Decimal>;
    // (undocumented)
    getNumberOfTroves(): Promise<number>;
    // (undocumented)
    getPrice(): Promise<Decimal>;
    // (undocumented)
    getStabilityDeposit(address?: string): Promise<StabilityDeposit>;
    // (undocumented)
    getTotal(): Promise<Trove>;
    // (undocumented)
    getTotalRedistributed(): Promise<Trove>;
    // (undocumented)
    getTotalStakedLQTY(): Promise<Decimal>;
    // (undocumented)
    getTrove(address?: string): Promise<Trove>;
    // (undocumented)
    getTroveWithoutRewards(address?: string): Promise<TroveWithPendingRewards>;
}

// @public (undocumented)
export type RedemptionDetails = {
    attemptedLUSDAmount: Decimal;
    actualLUSDAmount: Decimal;
    collateralReceived: Decimal;
    fee: Decimal;
};

// @public (undocumented)
export type RedemptionOptionalParams = HintedMethodOptionalParams & {
    price?: Decimal;
};

// @public (undocumented)
export type Sendable<T, R = unknown, S = unknown> = {
    [M in keyof T]: T[M] extends (...args: infer A) => Promise<infer D> ? SendMethod<A, SentLiquityTransaction<S, LiquityReceipt<R, D>>> : never;
};

// @public (undocumented)
export type SendableFrom<T> = {
    [M in keyof T]: T[M] extends PopulateMethod<infer A, PopulatedLiquityTransaction<unknown, infer U>> ? SendMethod<A, U> : never;
};

// @public (undocumented)
export const sendableFrom: <T, U extends Populatable<T, unknown, unknown, unknown>>(Populatable: new (...args: never[]) => U) => new (populatable: U) => SendableFrom<U>;

// @public (undocumented)
export type SendMethod<A extends unknown[], T extends SentLiquityTransaction> = (...args: A) => Promise<T>;

// @public (undocumented)
export type SentLiquityTransaction<S = unknown, T extends LiquityReceipt = LiquityReceipt> = {
    rawSentTransaction: S;
    getReceipt(): Promise<T>;
    waitForReceipt(): Promise<Extract<T, MinedReceipt>>;
};

// @public (undocumented)
export class StabilityDeposit {
    // Warning: (ae-forgotten-export) The symbol "StabilityDepositish" needs to be exported by the entry point index.d.ts
    constructor({ initialLUSD, currentLUSD, collateralGain, lqtyReward }: StabilityDepositish);
    // (undocumented)
    apply(change: StabilityDepositChange<Decimalish> | undefined): Decimal;
    // (undocumented)
    readonly collateralGain: Decimal;
    // (undocumented)
    readonly currentLUSD: Decimal;
    // (undocumented)
    equals(that: StabilityDeposit): boolean;
    // (undocumented)
    readonly initialLUSD: Decimal;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    readonly lqtyReward: Decimal;
    // (undocumented)
    toString(): string;
    // (undocumented)
    whatChanged(thatLUSD: Decimalish): StabilityDepositChange<Decimal> | undefined;
}

// @public (undocumented)
export type StabilityDepositChange<T> = {
    depositLUSD: T;
    withdrawLUSD?: undefined;
} | {
    depositLUSD?: undefined;
    withdrawLUSD: T;
    withdrawAllLUSD: boolean;
};

// @public (undocumented)
export type StabilityDepositChangeDetails = StabilityPoolGainsWithdrawalDetails & {
    change: StabilityDepositChange<Decimal>;
};

// @public (undocumented)
export type StabilityPoolGainsWithdrawalDetails = {
    lusdLoss: Decimal;
    newLUSDDeposit: Decimal;
    collateralGain: Decimal;
    lqtyReward: Decimal;
};

// @public (undocumented)
export type SuccessfulReceipt<R = unknown, D = unknown> = {
    status: "succeeded";
    rawReceipt: R;
    details: D;
};

// @public (undocumented)
export const successfulReceipt: <R, D>(rawReceipt: R, details: D, toString?: (() => string) | undefined) => SuccessfulReceipt<R, D>;

// @public (undocumented)
export type TaggedInvalidTroveCreation = {
    type: "invalidCreation";
    invalidTrove: Trove;
    error: TroveCreationError;
};

// @public (undocumented)
export type TaggedTroveAdjustment<T> = {
    type: "adjustment";
    params: TroveAdjustment<T>;
    setToZero?: "collateral" | "debt";
};

// @public (undocumented)
export type TaggedTroveClosure<T> = {
    type: "closure";
    params: TroveClosure<T>;
};

// @public (undocumented)
export type TaggedTroveCreation<T> = {
    type: "creation";
    params: TroveCreation<T>;
};

// @public (undocumented)
export type TransactableFrom<T> = {
    [M in keyof T]: T[M] extends SendMethod<infer A, SentLiquityTransaction<unknown, LiquityReceipt<unknown, infer D>>> ? (...args: A) => Promise<D> : never;
};

// @public (undocumented)
export const transactableFrom: <T, U extends Sendable<T, unknown, unknown>>(Sendable: new (...args: never[]) => U) => new (sendable: U) => TransactableFrom<U>;

// @public (undocumented)
export interface TransactableLiquity {
    // (undocumented)
    adjustTrove(params: TroveAdjustment<Decimalish>): Promise<TroveAdjustmentDetails>;
    // (undocumented)
    borrowLUSD(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    // (undocumented)
    claimCollateralSurplus(): Promise<void>;
    // (undocumented)
    closeTrove(): Promise<TroveClosureDetails>;
    // (undocumented)
    depositCollateral(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    // (undocumented)
    depositLUSDInStabilityPool(amount: Decimalish, frontendTag?: string): Promise<StabilityDepositChangeDetails>;
    // (undocumented)
    liquidate(address: string): Promise<LiquidationDetails>;
    // (undocumented)
    liquidateUpTo(maximumNumberOfTrovesToLiquidate: number): Promise<LiquidationDetails>;
    // (undocumented)
    openTrove(params: TroveCreation<Decimalish>): Promise<TroveCreationDetails>;
    // (undocumented)
    redeemLUSD(amount: Decimalish): Promise<RedemptionDetails>;
    // (undocumented)
    registerFrontend(kickbackRate: Decimalish): Promise<void>;
    // (undocumented)
    repayLUSD(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    // (undocumented)
    sendLQTY(toAddress: string, amount: Decimalish): Promise<void>;
    // (undocumented)
    sendLUSD(toAddress: string, amount: Decimalish): Promise<void>;
    // (undocumented)
    setPrice(price: Decimalish): Promise<void>;
    // (undocumented)
    stakeLQTY(amount: Decimalish): Promise<void>;
    // (undocumented)
    transferCollateralGainToTrove(): Promise<CollateralGainTransferDetails>;
    // (undocumented)
    unstakeLQTY(amount: Decimalish): Promise<void>;
    // (undocumented)
    withdrawCollateral(amount: Decimalish): Promise<TroveAdjustmentDetails>;
    // (undocumented)
    withdrawGainsFromStabilityPool(): Promise<StabilityPoolGainsWithdrawalDetails>;
    // (undocumented)
    withdrawGainsFromStaking(): Promise<void>;
    // (undocumented)
    withdrawLUSDFromStabilityPool(amount: Decimalish): Promise<StabilityDepositChangeDetails>;
}

// @public (undocumented)
export class Trove {
    constructor({ collateral, debt }?: Trovish);
    // (undocumented)
    add({ collateral, debt }: Trovish): Trove;
    // (undocumented)
    addCollateral(collateral: Decimalish): Trove;
    // (undocumented)
    addDebt(debt: Decimalish): Trove;
    // (undocumented)
    adjust(params: TroveAdjustment<Decimalish>, borrowingFeeFactor?: Decimalish): Trove;
    // (undocumented)
    adjustTo(that: Trove, borrowingFeeFactor?: Decimalish): TroveAdjustment<Decimal>;
    // (undocumented)
    apply(change: TroveChange<Decimalish> | undefined, borrowingFeeFactor?: Decimalish): Trove;
    // (undocumented)
    readonly collateral: Decimal;
    // (undocumented)
    collateralRatio(price: Decimalish): Decimal;
    // (undocumented)
    collateralRatioIsBelowCritical(price: Decimalish): boolean;
    // (undocumented)
    collateralRatioIsBelowMinimum(price: Decimalish): boolean;
    // (undocumented)
    static create(params: TroveCreation<Decimalish>, borrowingFeeFactor?: Decimalish): Trove;
    // (undocumented)
    static readonly CRITICAL_COLLATERAL_RATIO: Decimal;
    // (undocumented)
    readonly debt: Decimal;
    // (undocumented)
    equals(that: Trove): boolean;
    static readonly GAS_COMPENSATION_DEPOSIT: Decimal;
    // (undocumented)
    get isEmpty(): boolean;
    // (undocumented)
    isOpenableInRecoveryMode(price: Decimalish): boolean;
    // (undocumented)
    static readonly MINIMUM_COLLATERAL_RATIO: Decimal;
    // (undocumented)
    multiply(multiplier: Decimalish): Trove;
    // (undocumented)
    get netDebt(): Decimal;
    // (undocumented)
    get nominalCollateralRatio(): Decimal;
    // (undocumented)
    static recreate(that: Trove, borrowingFeeFactor?: Decimalish): TroveCreation<Decimal>;
    // (undocumented)
    setCollateral(collateral: Decimalish): Trove;
    // (undocumented)
    setDebt(debt: Decimalish): Trove;
    // (undocumented)
    subtract(that: Trovish): Trove;
    // (undocumented)
    subtractCollateral(collateral: Decimalish): Trove;
    // (undocumented)
    subtractDebt(debt: Decimalish): Trove;
    // (undocumented)
    toString(): string;
    // (undocumented)
    whatChanged(that: Trove, borrowingFeeFactor?: Decimalish): TroveChange<Decimal> | undefined;
}

// Warning: (ae-forgotten-export) The symbol "CollateralChange" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoDebtChange" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "DebtChange" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoCollateralChange" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type TroveAdjustment<T> = (CollateralChange<T> & NoDebtChange) | (DebtChange<T> & NoCollateralChange) | (CollateralChange<T> & DebtChange<T>);

// @public (undocumented)
export const troveAdjustment: <T>(params: TroveAdjustment<T>, setToZero?: "collateral" | "debt" | undefined) => TaggedTroveAdjustment<T>;

// @public (undocumented)
export type TroveAdjustmentDetails = TroveChangeWithFees<TroveAdjustment<Decimal>>;

// @public (undocumented)
export type TroveAdjustmentOptionalParams = FeelessTroveAdjustmentOptionalParams & {
    fees?: Fees;
};

// @public (undocumented)
export type TroveChange<T> = TaggedInvalidTroveCreation | TaggedTroveCreation<T> | TaggedTroveClosure<T> | TaggedTroveAdjustment<T>;

// @public (undocumented)
export type TroveChangeWithFees<T> = {
    params: T;
    newTrove: Trove;
    fee: Decimal;
};

// Warning: (ae-forgotten-export) The symbol "CollateralWithdrawal" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoCollateralDeposit" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "LUSDRepayment" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoLUSDBorrowing" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type TroveClosure<T> = CollateralWithdrawal<T> & NoCollateralDeposit & Partial<LUSDRepayment<T>> & NoLUSDBorrowing;

// @public (undocumented)
export const troveClosure: <T>(params: TroveClosure<T>) => TaggedTroveClosure<T>;

// @public (undocumented)
export type TroveClosureDetails = {
    params: TroveClosure<Decimal>;
};

// Warning: (ae-forgotten-export) The symbol "CollateralDeposit" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoCollateralWithdrawal" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "LUSDBorrowing" needs to be exported by the entry point index.d.ts
// Warning: (ae-forgotten-export) The symbol "NoLUSDRepayment" needs to be exported by the entry point index.d.ts
//
// @public (undocumented)
export type TroveCreation<T> = CollateralDeposit<T> & NoCollateralWithdrawal & Partial<LUSDBorrowing<T>> & NoLUSDRepayment;

// @public (undocumented)
export const troveCreation: <T>(params: TroveCreation<T>) => TaggedTroveCreation<T>;

// @public (undocumented)
export type TroveCreationDetails = TroveChangeWithFees<TroveCreation<Decimal>>;

// @public (undocumented)
export type TroveCreationError = "missingGasDeposit";

// @public (undocumented)
export type TroveCreationOptionalParams = HintedMethodOptionalParams & {
    fees?: Fees;
};

// @public (undocumented)
export class TroveWithPendingRewards extends Trove {
    // Warning: (ae-forgotten-export) The symbol "TrovishWithPendingRewards" needs to be exported by the entry point index.d.ts
    constructor({ collateral, debt, stake, snapshotOfTotalRedistributed }?: TrovishWithPendingRewards);
    // (undocumented)
    applyRewards(totalRedistributed: Trove): Trove;
    // (undocumented)
    equals(that: TroveWithPendingRewards): boolean;
    // (undocumented)
    readonly snapshotOfTotalRedistributed: Trove;
    // (undocumented)
    readonly stake: Decimal;
}

// @public (undocumented)
export interface Trovish {
    // (undocumented)
    readonly collateral?: Decimalish;
    // (undocumented)
    readonly debt?: Decimalish;
}


// (No @packageDocumentation comment for this package)

```
